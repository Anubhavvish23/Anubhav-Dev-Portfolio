import {
  AnimatePresence,
  motion
} from "./chunk-G5W3HEG2.js";
import {
  require_with_selector
} from "./chunk-SKF34X3Q.js";
import {
  require_jsx_runtime
} from "./chunk-NRBATONI.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/react-mouse-follower/dist/index.esm.js
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/react-mouse-follower/node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/react-mouse-follower/node_modules/zustand/esm/index.mjs
var import_react = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var { useDebugValue } = import_react.default;
var { useSyncExternalStoreWithSelector } = import_with_selector.default;
var didWarnAboutEqualityFn = false;
var identity = (arg) => arg;
function useStore(api, selector = identity, equalityFn) {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
var createImpl = (createState) => {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? createStore(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// node_modules/react-mouse-follower/dist/index.esm.js
var import_react2 = __toESM(require_react());
var log = (config) => (set, get, api) => config((args) => {
  const prev = get();
  if (prev.logging) {
    console.log("  applying", args);
    set(args);
    console.log("  new state", get());
  } else {
    set(args);
  }
}, get, api);
var useMouseStore = create(log((set) => ({
  curSettings: {},
  layers: [],
  logging: false,
  pushLayer: (newLayer) => set((state) => {
    const newCur = Object.assign(Object.assign({}, state.curSettings), newLayer);
    state.layers.push(newCur);
    return { layers: state.layers, curSettings: newCur };
  }),
  popLayer: () => set((state) => {
    if (state.layers.length > 1) {
      state.layers.pop();
      return { layers: state.layers, curSettings: state.layers.at(state.layers.length - 1) };
    } else {
      return { layers: [], curSettings: {} };
    }
  }),
  clearLayers: () => set((state) => {
    return { layers: [], curSettings: {} };
  }),
  log: () => set((state) => {
    return { logging: !state.logging };
  })
})));
function UpdateFollower({ mouseOptions, style, className, onMouseEnter, onMouseLeave, onClick, children }) {
  const { addLayer, removeLayer } = useMouseStore((state) => ({ addLayer: state.pushLayer, removeLayer: state.popLayer }));
  function handleMouseEnter() {
    addLayer(mouseOptions);
    if (onMouseEnter) {
      onMouseEnter();
    }
  }
  function handleMouseLeave() {
    removeLayer();
    if (onMouseLeave != null) {
      onMouseLeave();
    }
  }
  return (0, import_jsx_runtime.jsx)("div", { style, className, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, onClick, children });
}
function FollowerDiv({ pos, options }) {
  const calculatePosition = () => {
    if (options.customLocation != null) {
      return { x: options.customLocation.x, y: options.customLocation.y };
    } else if (options.customPosition != null) {
      const rect = options.customPosition.current.getBoundingClientRect();
      const radius = options.radius ? options.radius : 12 / 2;
      const x = rect.left + rect.width / 2 - radius;
      const y = rect.top + rect.height / 2 - radius;
      return { x, y };
    } else {
      return { x: pos.x, y: pos.y };
    }
  };
  return (0, import_jsx_runtime.jsx)(motion.div, { initial: {
    x: pos.x,
    y: pos.y,
    scale: 0,
    backgroundColor: options.backgroundColor || "black",
    zIndex: options.zIndex || -5,
    mixBlendMode: options.mixBlendMode || "initial"
  }, animate: {
    x: calculatePosition().x,
    y: calculatePosition().y,
    scale: options.scale != null ? options.scale : 1,
    rotate: options.rotate || 0,
    backgroundColor: options.backgroundColor || "black",
    zIndex: options.zIndex || -5,
    mixBlendMode: options.mixBlendMode || "initial"
  }, style: {
    position: "fixed",
    inset: 0,
    pointerEvents: "none",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    width: "min-content",
    height: "min-content",
    borderRadius: "9999px",
    overflow: "hidden"
  }, transition: { type: "tween", duration: options.followSpeed ? 0.3 / options.followSpeed : 0.3, ease: "circOut" }, id: "mouse-follower", children: (0, import_jsx_runtime.jsx)("div", { style: {
    width: `${options.radius ? options.radius * 2 : 12}px`,
    height: `${options.radius ? options.radius * 2 : 12}px`,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "transparent"
  }, children: (0, import_jsx_runtime.jsxs)("div", { style: {
    width: "100%",
    height: "100%",
    borderRadius: "9999px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    overflow: "hidden"
  }, children: [options.text && !options.backgroundElement ? (0, import_jsx_runtime.jsx)(motion.p, { initial: { opacity: 0.7 }, animate: { opacity: 1 }, transition: { type: "tween", duration: options.followSpeed ? 0.3 / options.followSpeed : 0.3, ease: "circOut" }, style: {
    width: "85%",
    textAlign: "center",
    lineHeight: options.textLineHeight,
    letterSpacing: options.textLetterSpacing,
    fontFamily: options.textFontFamily,
    fontSize: options.textFontSize ? options.textFontSize : "12px",
    color: options.textColor ? options.textColor : "white"
  }, children: options.text }) : null, (0, import_jsx_runtime.jsx)(AnimatePresence, { mode: "wait", children: options.backgroundElement ? (0, import_jsx_runtime.jsx)(motion.div, { style: {
    width: "100%",
    height: "100%",
    borderRadius: "9999px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    overflow: "hidden"
  }, animate: { opacity: 1 }, exit: { opacity: 0.3 }, transition: { type: "tween", duration: options.followSpeed ? 0.3 / options.followSpeed : 0.3, ease: "circOut" }, children: options.backgroundElement }) : null })] }) }) });
}
var defaultRadius = 12 / 2;
function FollowerInitialiserComponent() {
  const [isHovering, setIsHovering] = (0, import_react2.useState)(false);
  const options = useMouseStore((store) => store.curSettings);
  (0, import_react2.useEffect)(() => {
    const handleMouseLeave = () => {
      setIsHovering(false);
    };
    const handleMouseEnter = () => {
      setIsHovering(true);
    };
    const body = document.querySelector("body");
    body.addEventListener("mouseleave", handleMouseLeave);
    body.addEventListener("mouseenter", handleMouseEnter);
    return () => {
      body.removeEventListener("mouseleave", handleMouseLeave);
      body.removeEventListener("mouseenter", handleMouseEnter);
    };
  }, []);
  return (0, import_jsx_runtime.jsx)(ManagePosition, { options: !isHovering ? Object.assign(Object.assign({}, options), { scale: 0, customLocation: null, customPosition: null }) : options });
}
function ManagePosition({ options }) {
  const [pos, setPos] = (0, import_react2.useState)({
    x: 0,
    y: 0
  });
  (0, import_react2.useEffect)(() => {
    const mouseMove = (event) => {
      if (options.radius != null) {
        setPos({
          x: event.clientX - options.radius,
          y: event.clientY - options.radius
        });
      } else {
        setPos({
          x: event.clientX - defaultRadius,
          y: event.clientY - defaultRadius
        });
      }
    };
    window.addEventListener("mousemove", mouseMove);
    return () => {
      window.removeEventListener("mousemove", mouseMove);
    };
  }, [options === null || options === void 0 ? void 0 : options.radius]);
  return (0, import_jsx_runtime.jsx)(AnimatePresence, { mode: "wait", children: options.visible !== false ? (0, import_jsx_runtime.jsx)(FollowerDiv, { options, pos }) : null });
}
function MouseFollower() {
  return (0, import_jsx_runtime.jsx)(FollowerInitialiserComponent, {});
}
function useControlOptions() {
  const store = useMouseStore((state) => ({
    topLayer: state.layers[state.layers.length > 0 ? state.layers.length - 1 : null],
    addOptionLayer: state.pushLayer,
    removePreviousLayer: state.popLayer,
    clearLayers: state.clearLayers,
    log: state.log
  }));
  return Object.assign({}, store);
}
export {
  MouseFollower,
  UpdateFollower,
  useControlOptions
};
//# sourceMappingURL=react-mouse-follower.js.map
